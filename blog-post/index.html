<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-09-26 Mon 07:12 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Lambda calculus</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Justin Lange" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript" src="lambda.js"></script>
<style type="text/css">body {color: #333333; max-width: 50em; margin: auto;} a {color: #333333;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Lambda calculus</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. A simple programming language</a></li>
<li><a href="#orgheadline6">2. Church encoding</a>
<ul>
<li><a href="#orgheadline2">2.1. Numbers</a></li>
<li><a href="#orgheadline3">2.2. Booleans</a></li>
<li><a href="#orgheadline4">2.3. Linked Lists</a></li>
<li><a href="#orgheadline5">2.4. Encoding with functions</a></li>
</ul>
</li>
<li><a href="#orgheadline7">3. Reduction strategies</a></li>
<li><a href="#orgheadline8">4. Recursion</a></li>
<li><a href="#orgheadline13">5. A lambda calculus reducer in Python</a>
<ul>
<li><a href="#orgheadline9">5.1. <span class="todo TODO">TODO</span> Finish lambda calculus reducer with explanation of <code>fix</code></a></li>
<li><a href="#orgheadline10">5.2. <span class="todo TODO">TODO</span> Implement lambda calculus parser so we can run examples in code</a></li>
<li><a href="#orgheadline11">5.3. <span class="todo TODO">TODO</span> Make lambda calculator iterative?</a></li>
<li><a href="#orgheadline12">5.4. <span class="todo TODO">TODO</span> Implement, explain alpha renamer</a></li>
</ul>
</li>
<li><a href="#orgheadline14">6. Uses for lambda calculus</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> A simple programming language</h2>
<div class="outline-text-2" id="text-1">
<p>
Lambda calculus is a very simple programming language. It was
created as a way of modeling algorithms in the 1930s when people were
wondering about how to classify formal languages (like programming
languages). In particular, lambda calculus was provided as an
example of a language with language that one cannot prove will or will
not halt. lambda calculus is interesting because, despite its
simplicity, it can be used to model any computer language!
</p>

<p>
Lambda calculus is very simple. Like normal programming languages,
we have variables. We also have anonymous functions, denoted with the
lambda, a single parameter, and a lambda calculus expression as the
body. Finally, there are applications of those functions, which
replace uses of the function's parameter with the operand of the
function. Here are some basic lambda calculus expressions, and their
"results":
</p>

<pre class="example">
x              ; x                               -&gt; x
f x y          ; f(x)(y)
λx.x y         ; (lambda x: x)(y)                -&gt; y
(λx.λy.x) y z  ; (lambda x: (lambda y: x))(y)(z) -&gt; z
</pre>

<p>
Notice in the last example how the function returns another
function. This can be used to represent functions of many parameters,
and is called "currying." Furthermore, notice how <code>f x y</code> means "apply
<code>f</code> to <code>x</code>, then that result to <code>y</code>." Finally, in lambda calculus
there are no "unbound variable errors." A variable which is "unbound"
is instead said to be "free" in lambda calculus, and is merely
returned as is.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">2</span> Church encoding</h2>
<div class="outline-text-2" id="text-2">
<p>
With just variables, functions, and applications, we have a
way of replicating any algorithm. How can this be true if our language
doesn't have numbers, operators on those numbers, loops, strings, or
the myriad of features contained in languages like Python?
</p>

<p>
First off, how little can we get away with? We know that strings are
really just data structures holding numbers which are used to encode
characters, so if we have numbers and a basic data structure we can
have strings. Similarly, if we have the numbers 1 and 0, we can
pretend those also mean "true" and "false."
</p>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">2.1</span> Numbers</h3>
<div class="outline-text-3" id="text-2-1">
<p>
It turns out that we can encode numbers as functions, in the same way
that we're used to having numbers represent strings. First, we
represent zero:
</p>

<pre class="example">
ZERO = λf.λx.x  ; lambda f: (lambda x: x)
</pre>

<p>
Then we represent positive numbers with a different of n to zero as
the application of f n times to the normal result of zero:
</p>

<pre class="example">
ONE = λf.λx.f x            ; lambda f: (lambda x: f(x))
TWO = λf.λx.f (f x)        ; lambda f: (lambda x: f(f(x)))
THREE = λf.λx.f (f (f x))  ; lambda f: (lambda x: f(f(f(x))))
</pre>
<p>
etc.
</p>

<p>
Notice how instead of having a value which represents zero, we use a
parameter on a function, and instead of having a function which adds 1
to its input, we have another parameter. We can apply our Python
representions to those values to "translate" our encoding into a
normal Python number:
</p>

<pre class="example">
lambda_three = lambda f: (lambda x: f(f(f(x))))
python_add1 = lambda x: x + 1
python_zero = 0
lambda_three(python_add1)(python_zero)  # 3
</pre>

<p>
We can abstract the concept of incrementing a number easily enough:
</p>

<pre class="example">
λn.λf.λx.(f (n f x))
</pre>

<p>
This is a function that says "take a number (i.e., a function which
receives a representation of add1 and zero) and return one greater
than that number (i.e., return another function which takes a
representation of add1 and zero, and apply the original number to that
add1 and zero, but then apply add1 just one more time).
</p>

<p>
Addition is easy enough to get from here. Because our numbers are just
functions which take add1 and zero and apply add1 a number of times to
zero, we can supply "zero" as one of the numbers and add1 as itself:
</p>

<pre class="example">
λn.λm.n ADD1 m
</pre>

<p>
or, substituting ADD1 for its definition above:
</p>

<pre class="example">
λn.λm.n (λn.λf.λx.(f (n f x))) m
</pre>

<p>
Multiplication, exponentiation, subtraction, and division are all
possible to represent in lambda calculus. From here, boolean operators
are simple.
</p>

<p>
sub1, the opposite of add1, is difficult to define. Here it is:
</p>

<pre class="example">
SUB1 = λn.λf.λx.n (λg.λh. h (g f)) (λu.x) (λu.u)
</pre>

<p>
Try to simplify <code>SUB1 (λf.λx.f (f x))</code> by hand to see how it computes
2-1 = 1. Notice how <code>SUB1 (λf.λx.x)</code> is <code>(λf.λx.x)</code> (i.e., using this
encoding, 0-1 = 0).
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">2.2</span> Booleans</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Here we define false and true. They are functions which take two
values, one to be returned as meaning "true" and the other to be
returned as meaning "false."
</p>

<pre class="example">
TRUE = λt.λf.t   ; lambda t: (lambda f: t)
FALSE = λt.λf.f  ; lambda t: (lambda f: f)
</pre>

<p>
Which is true and which is false? It doesn't matter as long as we're
consistent with our decision, but notice how the second is identical
to how we represent zero. For this (admittedly weak) reason, we'll
call the first true and the second false. Once again, we can convert
these values to their Python equivalents by simply applying the real
True and False:
</p>

<pre class="example">
(lambda t: (lambda f: t))(True)(False)  # True
(lambda t: (lambda f: f))(True)(False)  # False
</pre>

<p>
Pretty basic! If-then-else statements can be constructed by applying
the boolean to the then and else branches:
</p>

<pre class="example">
IF = λx.λt.λf.x t f  ; lambda x: (lambda t: (lambda f: x(t)(f)))
</pre>

<p>
For example, suppose we want to return <code>A</code> if some expression is true
or <code>B</code> otherwise. First, we define a function that takes "some
expression":
</p>

<pre class="example">
λx ...
</pre>

<p>
And we fill in its body by applying our if-then-else to that
expression, as well as <code>A</code> and <code>B</code>:
</p>

<pre class="example">
λx.(λx.λt.λf.x t f) x A B
</pre>

<p>
which has a body we can reduce to:
</p>

<pre class="example">
λx.x A B
</pre>

<p>
Because we know true takes two values and returns the first, and false
does the same but returns the second, the above form is clearly
correct.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">2.3</span> Linked Lists</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Unsurprisingly, we can represent data structures as functions as
well. Here is a function which takes two values and binds them as a
tuple:
</p>

<pre class="example">
PAIR = λa.λb.λf.f a b
</pre>

<p>
Instead of returing a data structure, we return a function which takes
a function as its argument and applies that function to the values
created in the data structure. How about getting those values back?
</p>

<pre class="example">
HEAD = λp.p (λa.λb.a)
TAIL = λp.p (λa.λb.b)
</pre>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">2.4</span> Encoding with functions</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The concept of encoding numbers, booleans, and other data types in
lambda calculus using abstractions is called Church encoding. This is
due to Alonzo Church, the inventor of lambda calculus.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">3</span> Reduction strategies</h2>
<div class="outline-text-2" id="text-3">
<p>
Before we talk about recursion, it's important that we talk about two
major ways of making lambda calculus expressions more simple. In
particular, we care about whether a functions argument gets reduced
before it gets substituted as an argument. If we do reduce an argument
fully before applying it, we are using applicative order. Otherwise,
we are using normal order. This is glossing over an important fact of
lambda calculus, and the way that it is <i>not</i> a programming
language: there is no single way to reduce a function
application. However, more useful for us is normal order
reduction. Although this is not how programming languages are normally
evaluated (Python, including others, are applicative order; lazy
languages like Haskell more closely resemble normal order), we choose
it because it means that if a function has a "finished" form, that
form will be returned. Take, for example, the following:
</p>

<pre class="example">
(λi.x) ((λx.x x)(λx.x x))
</pre>

<p>
If we first evaluate <code>((λx.x x)(λx.x x))</code>, as in applicative order
reduction, we enter an infinite loop:
</p>

<pre class="example">
(λi.x) ((λx.x x)(λx.x x))
(λi.x) ((λx.x x)(λx.x x))
</pre>
<p>
etc.
</p>

<p>
However, if we do not attempt to unravel the operand first, we
immediately return the free variable x.
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">4</span> Recursion</h2>
<div class="outline-text-2" id="text-4">
<p>
How about loops? Clearly we don't have any sort of iteration
structure. Can we recur? The answer is yes, but without a way to
define values, how are we supposed to have a function refer to itself?
First we define our recursive function instead as a function which
takes a parameter which means "me" or "recur", and returns how it
would normally be defined. Then we write a function which takes a
function as its argument and hands that function itself, but a version
of itself which can also refer to itself. There are infinitely many
such functions which can do this (and they are called fixed point
combinators), but one of the most simple ones is called the Y
combinator. Here it is:
</p>

<pre class="example">
Y = λf.(λx. f(x x))(λx. f(x x))
</pre>

<p>
To see it in action, let's define a recursive add. In the below
example, a is merely a parameter which means "add":
</p>

<pre class="example">
ZERO? = λn.n (λx.TRUE) FALSE
</pre>

<pre class="example">
ADD = Y (λa.λm.λn. IF (ZERO? m) n (a (SUB1 m) (ADD1 n)))
</pre>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">5</span> A lambda calculus reducer in Python</h2>
<div class="outline-text-2" id="text-5">
<p>
Here is a lambda calculus reducer in Python, with both normal order
and applicative order reducers. Here, an <code>abstraction</code> indicates a
lambda abstraction. For example, <code>λf.f f</code> is entered like so:
</p>

<pre class="example">
abstraction('f', application('f', 'f'))
</pre>

<p>
Here are the reducers:
</p>

<pre class="example">
from collections import namedtuple

abstraction = namedtuple('abstraction', 'param body')
application = namedtuple('application', 'lhs rhs')


def applicative_reduce(term):
    if isinstance(term, application):
        param, body = applicative_reduce(term.rhs)
        return substitute(param, body, applicative_reduce(term.lhs))
    else:
        return term


def normal_reduce(term):
    if isinstance(term, application):
        param, body = applicative_reduce(term.rhs)
        return substitute(param, body, term.lhs)
    else:
        return term
</pre>

<p>
Note how <code>applicative_reduce</code> evaluates both the operator and the
operand, while normal<sub>reduce</sub> merely passes in the operand. Neither do
anything when the term is an abstraction.
</p>

<pre class="example">
def substitute(param, body, x):
    if param == body:
        return x
    elif isinstance(body, str):
        return body
    elif isinstance(body, application):
        lhs, rhs = application
        return application(
            substitute(param, lhs, x),
            substitute(param, rhs, x)
        )
    elif param == body.param:
        return body
    else:
        return abstraction(body.param, substitute(param, body.body, x))
</pre>

<p>
<code>substitute</code> will only replace variables with <code>x</code> as long as those
variables are not bound within another function. Notice the
conditional <code>elif param == body.param</code>: if the parameter we're
replacing is equal to the parameter in the abstraction we've
encountered, we merely return that abstraction. Otherwise, we keep the
abstraction as is except for the body, which we substitute.
</p>

<pre class="example">
def fix(reducer, term):
    prev = None
    while term != prev:
      prev, term = term, reducer(term)
    return term
</pre>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">5.1</span> <span class="todo TODO">TODO</span> Finish lambda calculus reducer with explanation of <code>fix</code></h3>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">5.2</span> <span class="todo TODO">TODO</span> Implement lambda calculus parser so we can run examples in code</h3>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">5.3</span> <span class="todo TODO">TODO</span> Make lambda calculator iterative?</h3>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">5.4</span> <span class="todo TODO">TODO</span> Implement, explain alpha renamer</h3>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">6</span> Uses for lambda calculus</h2>
<div class="outline-text-2" id="text-6">
<p>
Lambda calculus remains a classic way of model computation. The
concepts are simple enough to be understood by beginners, yet
introduces enough complexity to model any algorithm. Many issues with
language implementation are worked out with lambda calculus reducers:
for example, alpha renaming is a real compilation strategy which
simplifies (and possibly optimizes) variable lookup. Modern languages
as diverse as Python and Haskell are indebted to lambda calculus and
the research accomplished using it.
</p>

<p>
A lambda calculus reducer is so simple to implement, that it is often
used to prove Turing-completeness. When a language is Turing-complete,
it shares with Lambda calculus the power of being able to simulate any
algorithm. When a language has this power, it is impossible to prove
that a program in that language will halt. That is to say, there
exists no algorithm which accepts any program written in a
Turing-complete language and returns whether or not that program runs
forever. In fact, the notion of Turing-completeness, and lambda
calculus itself, were originally invented as proof of this. Many other
"languages", as diverse as Conway's Game of Life, SQL, a number of
video games such as Minecraft, etc. are Turing-complete. However,
lambda calculus continues to be used, particularly in type theory
where lambda calculi augmented with various type systems are studied.
</p>
</div>
</div>
</div>
</body>
</html>
