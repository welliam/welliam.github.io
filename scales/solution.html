<!DOCTYPE html>

<head>
  <title>The New Solution</title>
  <link
     rel="icon"
     href="https://upload.wikimedia.org/wikipedia/commons/d/db/Chrysopoea_of_Cleopatra_1.gif"
     />
  <link href="scales-style.css"
        rel="stylesheet"
        type="text/css" />
</head>

<body>
  <h3>Finding MOLTs</h3>
  <p>
    Scales from any <var>n</var>-tone equal temperament scale (TET)
    can be represented as a binary number with TET digits (if one
    includes leading zero digits). For example, the C major scale in
    12-TET:
    <pre>
      1  0  1  0  1  0  1  1  0  1  0  1
      B  A# A  G# G  F# F  E  D# D  C# C</pre>
    which is 2741 in base 10. (This method of representing scales is
    key-agnostic and the key of C was chosen for readability) Notice
    how the least significant bit represents the lowest note in the
    scale&ndash; this is out of convenience, as the scale just
    containing the 1st note in the TET would be 1.  Thus, every
    possible scale would be represented as simply the numbers
    1+2<var>n</var><sup>[1]</sup>.
  </p>
  <p>
    Finding all the MOLTs first involves finding the unique prime
    factors of the TET, then using the factors <var>p</var> to
    generate a scale which equally divides the TET into <var>p</var>
    notes (called the prime scale). For each of these prime
    factors <var>p</var> of TET <var>t</var>, the corresponding scale
    is
    &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>.
    For example, the prime factors of 12 are 2 and 3, which means its
    prime scales are
    &#8721;<sub><var>n</var>=0</sub><sup>1</sup>2<sup>(12/2<var>n</var>)</sup>
    = 65 (the tritone) and
    &#8721;<sub><var>n</var>=0</sub><sup>2</sup>2<sup>(12/3<var>n</var>)</sup>
    = 273 (the augmented chord). This sum is of a geometric series and
    can be rewritten: <br />
    <pre>
      &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>
      &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>[2<sup>(<var>t</var>/<var>p)</sup>]<sup>n</sup></var></sup>
      (2<sup><var>(t</var>/<var>p</var>)((<var>p</var>-1)+1)</sup> - 1) / (2<sup><var>t/p</var></sup> - 1)
      (2<sup><var>t</var></sup> - 1) / (2<sup><var>t/p</var></sup> - 1).</pre>
  </p>

  </p>
  <p>
    These prime scales are MOLTs, and overlapping transpositions of
    these prime scales are MOLTs. The results of the linear
    equation
    <var>S</var> = <var>p</var>(2<var>n</var> + 1)
    where <var>p</var> is the prime scale being used,
    while <var>S</var> is less than 2<sup><var>tet</var></sup>.
  </p>
  <p>
    The number of MOLTs for a TET <var>t</var> generated by its prime
    factor <var>p</var> is given from the formula 2
    <sup><var>t</var>/<var>p</var> - 1</sup>.
    The total number of MOLTs in a TET is the sum of these for each
    prime factor of that TET. Note that this counts duplicate scales
    found by each prime twice or more. For example, the whole tone
    scale 1365 is both 65(20 + 1) and 273(4 + 1) (i.e. interpolation
    of the tritone by a whole tone and a major third and interpolation
    of the augmented chord once by a whole tone). Currently I don't
    see any way to skip these duplicates without just removing them.
  </p>

  <div>
    <h3>Arithmetic With Scales</h3>

  <p>
    Because scales are numbers, we can manipulate scales using
    arithmetic operations. Sometimes it makes more sense to consider
    operations on bits of the scale. For example, the union of scales
    <var>S1</var> and <var>S2</var> is given wth <var>S1</var>
    + <var>S2</var> where neither scale has any bits both equal to 1
    (i.e. no base 2 carries occur).
  </p>
  <p>
    While many of my formulas were found through "reverse engineering"
    (i.e. using prior knowledge of what MOLTs existed in base 12 and
    converting these scales to binary numbers), analysis of the
    meanings of these basic operations on scales is
    enlightening. Below I attempt to explain what each of the formulas
    are "saying":
  </p>

  <h4>
    &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>
    (the prime scale given by prime factor <var>p</var> of TET <var>t</var>)
  </h4>
  <p>
    As mentioned above, the sum of unique scales is the combination of
    those scales. 2<sup><var>n</var></sup> for any non-negative
    integer always creates scales which are unique from one another:
    <pre>
      2<sup>0</sup> = 001b
      2<sup>1</sup> = 010b
      2<sup>2</sup> = 100b
      etc.</pre>
    This example also demonstrates that
    2<sup><var>n</var></sup> + <var>S</var>
    where <var>S</var> does not already contain the <var>n</var>th
    note means "<var>S</var> with the <var>n</var>th note."
    2<sup><var>n</var></sup> itself is just the <var>n</var>th note.
  </p>
  <p>To see what is meant by 2<sup><var>t</var>/<var>pn</var></sup>,
  we look at a few examples for some
    <var>t</var>s, <var>p</var>s, and <var>n</var>s:
    <pre>
      2<sup>12/3(0)</sup> = 1   = 000000000001b = C
      2<sup>12/3(1)</sup> = 16  = 000000010000b = E
      2<sup>12/3(2)</sup> = 256 = 000100000000b = G#.</pre>
    The difference of the digit placement of 1 between each example is
    4 (that is, <var>p</var>/<var>t</var>). Prime scales of prime
    factor <var>p</var> are scales with <var>p</var> notes that are
    equally distributed.
  </p>

  <h4>
    <var>S</var> = <var>f</var>(<var>n</var>) = <var>p</var>(<var>n</var> + 1)
    (MOLTs from a prime scale <var>p</var>)
  </h4>
  <p>
    Properly speaking, this equation should be <var>pn</var> +
    1. However, as this does nothing but include the trivial scale of
    one note, I prefer
    <var>p</var>(<var>n</var> + 1),
    0 &le; <var>n</var> &lt; 2 <sup><var>t</var>/<var>p</var> - 1</sup>,
    n&isin;&#8469;<sub>0</sub>. I don't understand this formula.
  </p>

  <h4>
    (2<sup><var>t</var></sup> - 1) / (2<sup><var>t/p</var></sup> - 1)
    (equivalent to
    &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>)
  </h4>
  <p>
    The numerator, 2<sup><var>t</var></sup> - 1, is the chromatic
    scale in TET <var>t</var>; (chromatic scales are all binary
    <a href="https://en.wikipedia.org/wiki/Repdigit">repdigits</a>).
    The denominator is a binary repdigit
    with <var>t</var>/<var>p</var> digits. That is to say, it is a
    scale containing the first <var>t</var>/<var>p</var> notes of its
    TET. Division between two scales is ??????????????????? i don't
    even know if it's meaningful to think about this formula as
    divison between two scales
  <br />
  </p>

  <h3>Haskell Code</h3>
  <p>
    <pre>
      import Data.List

      primeFactors :: Integer -> [Integer]
      primeFactors x = [p | p <- sieve [2..x-1], x `mod` p == 0]

      sieve :: [Integer] -> [Integer]
      sieve [] = []
      sieve (a:b) = a : sieve (filter ((/=0).(`mod`a)) b)

      primeScale :: Integer -> Integer -> Integer
      primeScale tet prime = (1 - 2 ^ tet) `div` (1 - 2^(tet `div` prime))
      -- alternatively `sum [2 ^ (n * tet `div` prime) | n <- [0 .. prime]]`

      findMolts :: Integer -> Integer -> [Integer]
      findMolts tet ps = takeWhile (< 2^tet) [ps, ps*3..]

      molts :: Integer -> [Integer]
      molts tet = concatMap (findMolts tet . primeScale tet) (primeFactors tet)

      -- counting MOLTs

      countMolts :: Integer -> Integer
      countMolts tet = sum [countMoltsFromPrime tet p | p <- primeFactors tet]

      countMoltsFromPrime :: Integer -> Integer -> Integer
      countMoltsFromPrime tet prime = 2 ^ (tet `div` prime - 1)

      duplicatedMolts :: Integer -> [Integer]
      duplicatedMolts tet = foldr add [] ms
      where count x = length . filter (== x)
            add a sum = if count a ms > 1 && not (a `elem` sum) then a:sum else sum
            ms = molts tet

      -- showing scales

      twelveTones :: [String]
      twelveTones = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]

      showScale :: [a] -> Integer -> [a]
      showScale t s =
        [k | (k, n) <- zip t (takeWhile (>0) (iterate (`div` 2) s)), n `mod` 2 == 1]

      show12 :: Integer -> [String]
      show12 = showScale twelveTones

      printMolts :: [Integer] -> Integer -> IO ()
      printMolts scale = putStr
        . concatMap ((++ "\n") . concat . intersperse " " . showScale (map show scale))
        . molts

      printMolts' ::  Integer -> IO ()
      printMolts' = printMolts [0..]
    </pre>
  </p>

  <h3>Footnotes</h3>
  <p>
    1. Scales which do not include the first interval are not
       considered scales. My chosen interpretation is thus flawed, in
       that numbers carry irrelevant information; in all cases, the
       least significant bit could be dropped. However, the formulas
       for finding MOLTs currently take this number into account, and I
       am too lazy to rework them (for now).
  </p>

  <br /><a href="index.html">MOLTs</a>
</body>
