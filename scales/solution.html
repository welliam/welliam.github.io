<!DOCTYPE html>

<head>
  <title>Finding MOLTs as Numbers</title>
  <link
     rel="icon"
     href="https://upload.wikimedia.org/wikipedia/commons/d/db/Chrysopoea_of_Cleopatra_1.gif"
     />
  <link href="scales-style.css"
        rel="stylesheet"
        type="text/css" />
</head>

<body>

  <div id="MOLTs as Numbers">
    <h3>Finding MOLTs as Numbers</h3>
    <p>
      Scales from any <var>n</var>-tone equal temperament scale (TET)
      can be represented as a binary number with <var>n</var> digits
      (including leading zero digits). For example, the C major scale in
      12-TET:
      <pre>
        1  0  1  0  1  0  1  1  0  1  0  1 = 101010110101b
        B  A# A  G# G  F# F  E  D# D  C# C</pre>
      which is 2741 in base 10. (This method of representing scales is
      key-agnostic and the key of C was chosen for readability.) Notice
      how the least significant bit represents the lowest note in the
      scale&ndash; this is out of convenience, as the scale just
      containing the 1st note in the TET would be 1. Every
      possible scale is represented as the odd numbers
      2<var>n</var>+1, as we do not considers sets of notes which do not
      include the first note to be scales.
    </p>
    <p>
      Finding all the MOLTs first involves finding the unique prime
      factors of the TET, then using the factors <var>p</var> to
      generate a scale which equally divides the TET into <var>p</var>
      notes (called the prime scale). For each of these prime
      factors <var>p</var> of TET <var>t</var>, the corresponding prime
      scale is
      &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>.
      For example, the prime factors of 12 are 2 and 3, which means its
      prime scales are
      &#8721;<sub><var>n</var>=0</sub><sup>1</sup>2<sup>(12/2<var>n</var>)</sup>
      = 65 (the tritone) and
      &#8721;<sub><var>n</var>=0</sub><sup>2</sup>2<sup>(12/3<var>n</var>)</sup>
      = 273 (the augmented chord). This sum is of a geometric series and
      can be rewritten:
      <pre>
        &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>
        (2<sup><var>(t</var>/<var>p</var>)((<var>p</var>-1)+1)</sup> - 1) / (2<sup><var>t/p</var></sup> - 1)
        (2<sup><var>t</var></sup> - 1) / (2<sup><var>t/p</var></sup> - 1).
      </pre>
      These prime scales are MOLTs, and overlapping transpositions of
      these prime scales are MOLTs. The formula
      <var>S</var> = <var>p</var>(2<var>n</var> + 1)
      while <var>S</var> is less than 2<sup><var>tet</var></sup>
      represents all the MOLTs from prime scale <var>p</var>.
    </p>
    <p>
      The number of MOLTs for a TET <var>t</var> generated by its
      prime factor <var>p</var> is given from the formula 2
      <sup><var>t</var>/<var>p</var> - 1</sup>.
      The total number of MOLTs in a TET is the sum of these for each
      prime factor of that TET. Note that this counts duplicate scales
      found by each prime twice or more. For example, the whole tone
      scale 1365 is both 65(20 + 1) and 273(4 + 1) (i.e. interpolation
      of the tritone by a whole tone and a major third and interpolation
      of the augmented chord once by a whole tone). Currently I don't
      see any way to skip these duplicates without manual checking.
    </p>
  </div>

  <div id="Equations">
    <h3>Equations</h3>

    <p>
      Because scales are numbers, we can manipulate scales using
      arithmetic operations. For example, the union of scales
      <var>S1</var> and <var>S2</var> is given wth <var>S1</var>
      + <var>S2</var> where neither scale has any bits both equal to 1
      (i.e. no base 2 carries occur; in reality this is a
      <a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">bitwise
        OR</a>).
    </p>
    <h4>
      &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>
      (the prime scale given by prime factor <var>p</var> of TET <var>t</var>)
    </h4>
    <p>
      As mentioned above, the sum of unique scales is the combination of
      those scales. 2<sup><var>n</var></sup> for any non-negative
      integer always creates scales which are unique from one another:
      <pre>
        2<sup>0</sup> = 001b
        2<sup>1</sup> = 010b
        2<sup>2</sup> = 100b
        etc.</pre>
      This example also demonstrates that
      2<sup><var>n</var></sup> + <var>S</var>
      where <var>S</var> does not already contain the <var>n</var>th
      note means "<var>S</var> with the <var>n</var>th note."
      2<sup><var>n</var></sup> itself is just the <var>n</var>th note.
    </p>
    <p>To see what is meant by 2<sup><var>t</var>/<var>pn</var></sup>,
      we look at the augmented chord (where <var>t</var> is 12 and <var>p</var> is 3):
      <pre>
        2<sup>12/3(0)</sup> = 1   = 000000000001b = C
        2<sup>12/3(1)</sup> = 16  = 000000010000b = E
        2<sup>12/3(2)</sup> = 256 = 000100000000b = G#
      </pre>
      The difference of the digit position of 1 between each note is
      4 (that is, <var>p</var>/<var>t</var>). Prime scales of prime
      factor <var>p</var> are scales with <var>p</var> notes that are
      equally distributed.
    </p>

    <h4>
      <var>S</var> = <var>f</var>(<var>n</var>) = <var>p</var>(2<var>n</var> + 1)
      (MOLTs from a prime scale <var>p</var>)
    </h4>
    <p>
      Multiplication of prime scale P by another scale S means
      interpolating P by each note in S. For example, the whole tone
      scale is 65&times;21. 65 is the tritone 1000001b, and 21 is
      10101b, which is `C D E` in the key of C. Through multiplication
      the pattern C D E is transposed to each note contained in the
      tritone, yielding C D E (i.e. 21&times;1, where 1 is the first
      note contained in 65) plus F&#9839; G&#9839; A&#9839;
      (21&times;64, 64 being the note contained in the tritone).
    </p>
    <p>
      Essentially, this formula says that every possible scale
      (i.e. 2<var>n</var> + 1) between 1 and the first non-one interval
      of a prime scale multiplied by that prime scale is a MOLT.
    </p>

    <h4>
      (2<sup><var>t</var></sup> - 1) / (2<sup><var>t/p</var></sup> - 1)
      (equivalent to
      &#8721;<sub><var>n</var>=0</sub><sup><var>p</var>-1</sup>2<sup>(<var>t</var>/<var>pn</var>)</sup>)
    </h4>
    <p>
      The numerator, 2<sup><var>t</var></sup> - 1, is the chromatic
      scale in TET <var>t</var>; (chromatic scales are all binary
      <a href="https://en.wikipedia.org/wiki/Repdigit">repdigits</a>).
      The denominator is a binary repdigit
      with <var>t</var>/<var>p</var> digits. That is to say, it is a
      scale containing the first <var>t</var>/<var>p</var> notes of its
      TET. Division between two scales is ??????????????????? i don't
      even know if it's meaningful to think about this formula as
      divison between two scales
      <br />
    </p>
  </div>

  <h3>Haskell Code</h3>
  <p>
    <pre>
import Data.List

primeFactors :: Integer -> [Integer]
primeFactors x = [p | p <- sieve [2..x-1], x `mod` p == 0]

sieve :: [Integer] -> [Integer]
sieve [] = []
sieve (a:b) = a : sieve (filter ((/=0).(`mod`a)) b)

primeScale :: Integer -> Integer -> Integer
primeScale tet prime = (1 - 2 ^ tet) `div` (1 - 2^(tet `div` prime))
-- alternatively `sum [2 ^ (n * tet `div` prime) | n <- [0 .. prime]]`

findMolts :: Integer -> Integer -> [Integer]
findMolts tet ps = takeWhile (< 2^tet) [ps, ps*3..]

molts :: Integer -> [Integer]
molts tet = concatMap (findMolts tet . primeScale tet) (primeFactors tet)

-- showing scales

twelveTones :: [String]
twelveTones = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]

showScale :: [a] -> Integer -> [a]
showScale t s =
  [k | (k, n) <- zip t (takeWhile (>0) (iterate (`div` 2) s)), n `mod` 2 == 1]

show12 :: Integer -> [String]
show12 = showScale twelveTones

printMolts :: [Integer] -> Integer -> IO ()
printMolts scale = putStr
  . concatMap ((++ "\n") . concat . intersperse " " . showScale (map show scale))
  . molts

printMolts' ::  Integer -> IO ()
printMolts' = printMolts [0..]
    </pre>
  </p>

  <footer><a href="index.html">MOLTs</a></footer>
</body>
